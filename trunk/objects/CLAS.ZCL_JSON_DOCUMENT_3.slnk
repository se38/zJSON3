<?xml version="1.0" encoding="utf-8"?>
<CLAS CLSNAME="ZCL_JSON_DOCUMENT_3" VERSION="1" LANGU="E" DESCRIPT="JSON Document Class 3" CATEGORY="00" EXPOSURE="2" STATE="1" RELEASE="0" CLSFINAL="X" CLSCCINCL="X" FIXPT="X" UNICODE="X" CLSBCCAT="00" WITH_UNIT_TESTS="X" DURATION_TYPE="0 " RISK_LEVEL="0 ">
 <localImplementation>*&quot;* local class implementation for public class
*&quot;* use this source file for the implementation part of
*&quot;* local helper classes
TYPES: BEGIN OF t_int,
         i TYPE i,
       END OF t_int,
       BEGIN OF t_packed,
         p TYPE p LENGTH 10 DECIMALS 2,
       END OF t_packed,
       BEGIN OF t_numc,
         nc TYPE n LENGTH 4,
       END OF t_numc,
       BEGIN OF t_string,
         s TYPE string,
       END OF t_string,
       BEGIN OF t_struc1,
         i   TYPE i,
         nc  TYPE n LENGTH 4,
         p   TYPE p LENGTH 10 DECIMALS 2,
         s   TYPE string,
         c1  TYPE c LENGTH 1,
         c20 TYPE c LENGTH 20,
         x   TYPE xstring,
         dr  TYPE REF TO data,
       END OF t_struc1,
       BEGIN OF t_date,
         d TYPE d,
       END OF t_date,
       BEGIN OF t_namespace,
         /cex/test TYPE string,
         test      TYPE string,
       END OF t_namespace.

*----------------------------------------------------------------------*
*       CLASS lcl_zjson DEFINITION
*----------------------------------------------------------------------*
CLASS lcl_zjson DEFINITION FINAL FOR TESTING &quot;#AU Risk_Level Harmless
.                                            &quot;#AU Duration   Short
*  DURATION SHORT          &quot;&gt;= 7.02
*  RISK LEVEL HARMLESS.    &quot;&gt;= 7.02

  PRIVATE SECTION.
    DATA: json_doc  TYPE REF TO zcl_json_document_3,
          json_doc2 TYPE REF TO zcl_json_document_3,
          json_str  TYPE string.

    METHODS: test_number              FOR TESTING
      RAISING
        zcx_json_document_3,
      test_string_number       FOR TESTING
        RAISING
          zcx_json_document_3,
      test_string_escape       FOR TESTING
        RAISING
          zcx_json_document_3,
      test_string_number_struc FOR TESTING
        RAISING
          zcx_json_document_3,
      test_xstring             FOR TESTING
        RAISING
          zcx_json_document_3,
      test_dref                FOR TESTING
        RAISING
          zcx_json_document_3,
      test_number_struct       FOR TESTING
        RAISING
          zcx_json_document_3,
      test_append_data         FOR TESTING,
      test_string_table        FOR TESTING
        RAISING
          zcx_json_document_3,
      test_stru_table          FOR TESTING
        RAISING
          zcx_json_document_3,
      test_stru_table_named    FOR TESTING,
      test_parse_list_strings  FOR TESTING
        RAISING
          zcx_json_document_3,
      test_parse_flat_object   FOR TESTING
        RAISING
          zcx_json_document_3,
      test_date_format         FOR TESTING
        RAISING
          zcx_json_document_3,
      test_date_format_reverse FOR TESTING
        RAISING
          zcx_json_document_3,
      test_namespace           FOR TESTING
        RAISING
          zcx_json_document_3,
      test_boolean             FOR TESTING
        RAISING
          zcx_json_document_3,
      test_transform_simple    FOR TESTING
        RAISING
          zcx_json_document_3
          cx_xslt_format_error,
      test_name_values         FOR TESTING
        RAISING
          zcx_json_document_3.

ENDCLASS.                    &quot;lcl_zjson DEFINITION

*----------------------------------------------------------------------*
*       CLASS lcl_zjson IMPLEMENTATION
*----------------------------------------------------------------------*
CLASS lcl_zjson IMPLEMENTATION.

  METHOD test_number.
    DATA: tpacked  TYPE p LENGTH 10 DECIMALS 2,
          tpacked2 TYPE p LENGTH 10 DECIMALS 2,
          tfloat   TYPE f,
          tint     TYPE i,
          tint2    TYPE i,
          tnumc    TYPE n LENGTH 4,
          tnumc2   TYPE n LENGTH 4.

*   packed number
    tfloat = &apos;10.5&apos;.
    tpacked = tfloat.  &quot;conversion to packed
    json_doc = zcl_json_document_3=&gt;create_with_data( tpacked ).
    json_str = json_doc-&gt;get_json( ).
    cl_aunit_assert=&gt;assert_equals( exp = &apos;10.50&apos;
                                    act = json_str ).
    json_doc2 = zcl_json_document_3=&gt;create_with_json( json_str ).
    json_doc2-&gt;get_data( IMPORTING data = tpacked2 ).
    cl_aunit_assert=&gt;assert_equals( exp = tpacked
                                    act = tpacked2 ).

*   packed negative
    tfloat = &apos;-999.55&apos;.
    tpacked = tfloat.  &quot;conversion to packed
    json_doc = zcl_json_document_3=&gt;create_with_data( tpacked ).
    json_str = json_doc-&gt;get_json( ).
    cl_aunit_assert=&gt;assert_equals( exp = &apos;-999.55&apos;
                                    act = json_str ).
    json_doc2 = zcl_json_document_3=&gt;create_with_json( json_str ).
    json_doc2-&gt;get_data( IMPORTING data = tpacked2 ).
    cl_aunit_assert=&gt;assert_equals( exp = tpacked
                                    act = tpacked2 ).


*   integer
    tint = 10.
    json_doc = zcl_json_document_3=&gt;create_with_data( tint ).
    json_str = json_doc-&gt;get_json( ).
    cl_aunit_assert=&gt;assert_equals( exp = &apos;10&apos;
                                    act = json_str ).
    json_doc2 = zcl_json_document_3=&gt;create_with_json( json_str ).
    json_doc2-&gt;get_data( IMPORTING data = tint2 ).
    cl_aunit_assert=&gt;assert_equals( exp = tint
                                    act = tint2 ).

*   numc
    tnumc = &apos;00010&apos;.
    json_doc = zcl_json_document_3=&gt;create_with_data( tnumc ).
    json_str = json_doc-&gt;get_json( ).
    cl_aunit_assert=&gt;assert_equals( exp = &apos;&quot;0010&quot;&apos;
                                    act = json_str ).

    json_doc = zcl_json_document_3=&gt;create_with_data(
               data             = tnumc
               numc_as_numeric  = abap_true
           ).
    json_str = json_doc-&gt;get_json( ).
    cl_aunit_assert=&gt;assert_equals( exp = &apos;10&apos;
                                    act = json_str ).

    json_doc2 = zcl_json_document_3=&gt;create_with_json( json_str ).
    json_doc2-&gt;get_data( IMPORTING data = tnumc2 ).
    cl_aunit_assert=&gt;assert_equals( exp = tnumc
                                    act = tnumc2 ).

*   numc with just zeros
    tnumc = &apos;00000&apos;.
    json_doc = zcl_json_document_3=&gt;create_with_data( tnumc ).
    json_str = json_doc-&gt;get_json( ).
    cl_aunit_assert=&gt;assert_equals( exp = &apos;&quot;0000&quot;&apos;
                                    act = json_str ).

    json_doc = zcl_json_document_3=&gt;create_with_data(
               data             = tnumc
               numc_as_numeric  = abap_true
           ).
    json_str = json_doc-&gt;get_json( ).
    cl_aunit_assert=&gt;assert_equals( exp = &apos;0&apos;
                                    act = json_str ).

    json_doc2 = zcl_json_document_3=&gt;create_with_json( json_str ).
    json_doc2-&gt;get_data( IMPORTING data = tnumc2 ).
    cl_aunit_assert=&gt;assert_equals( exp = tnumc
                                    act = tnumc2 ).

  ENDMETHOD.                    &quot;test_number


  METHOD test_string_number.
    DATA: t_str  TYPE string,
          t_str2 TYPE string.

    t_str = &apos;0010&apos;.
    json_doc = zcl_json_document_3=&gt;create_with_data( t_str ).
    json_str = json_doc-&gt;get_json( ).
    cl_aunit_assert=&gt;assert_equals( exp = &apos;&quot;0010&quot;&apos;
                                    act = json_str ).
    json_doc2 = zcl_json_document_3=&gt;create_with_json( json_str ).
    json_doc2-&gt;get_data( IMPORTING data = t_str2 ).
    cl_aunit_assert=&gt;assert_equals( exp = t_str
                                    act = t_str2 ).

  ENDMETHOD.                    &quot;test_string_number

  METHOD test_string_escape.

    DATA: BEGIN OF t_struc,
            abc TYPE string VALUE &apos;def:&quot;123}&apos;,
          END OF t_struc.
    DATA t_str TYPE string.

    json_doc = zcl_json_document_3=&gt;create_with_data( t_struc ).
    json_str = json_doc-&gt;get_json( ).
    cl_aunit_assert=&gt;assert_equals( exp = &apos;{&quot;abc&quot; :&quot;def:\&quot;123}&quot;}&apos;
                                    act = json_str ).

    json_doc = zcl_json_document_3=&gt;create_with_json( json_str ).
    t_str = json_doc-&gt;get_value( &apos;abc&apos; ).

    cl_aunit_assert=&gt;assert_equals( exp = &apos;def:&quot;123}&apos;
                                    act = t_str ).

  ENDMETHOD.                    &quot;test_string_number


  METHOD test_string_number_struc.
    DATA: s_str  TYPE t_string,
          s_str2 TYPE t_string.

    s_str-s = &apos;0010&apos;.
    json_doc = zcl_json_document_3=&gt;create_with_data( s_str ).
    json_str = json_doc-&gt;get_json( ).
    cl_aunit_assert=&gt;assert_equals( exp = &apos;{&quot;s&quot; :&quot;0010&quot;}&apos;
                                    act = json_str ).
    json_doc2 = zcl_json_document_3=&gt;create_with_json( json_str ).
    json_doc2-&gt;get_data( IMPORTING data = s_str2 ).
    cl_aunit_assert=&gt;assert_equals( exp = s_str
                                    act = s_str2 ).
  ENDMETHOD.                    &quot;test_string_number_struc


  METHOD test_string_table.
    DATA: str     TYPE string,
          strtab  TYPE TABLE OF string,
          strtab2 TYPE TABLE OF string.

    str = &apos;0010&apos;. APPEND str TO strtab.
    str = &apos;0020&apos;. APPEND str TO strtab.
    str = &apos;0030&apos;. APPEND str TO strtab.

    json_doc = zcl_json_document_3=&gt;create_with_data( data = strtab suppress_itab = &apos;X&apos; ).
    json_str = json_doc-&gt;get_json( ).
    cl_aunit_assert=&gt;assert_equals( exp = &apos;[&quot;0010&quot;,&quot;0020&quot;,&quot;0030&quot;]&apos;
                                    act = json_str ).
    json_doc2 = zcl_json_document_3=&gt;create_with_json( json_str ).
    json_doc2-&gt;get_data( IMPORTING data = strtab2 ).
    cl_aunit_assert=&gt;assert_equals( exp = strtab
                                    act = strtab2 ).

  ENDMETHOD.                    &quot;test_string_table


  METHOD test_number_struct.
    DATA: tfloat    TYPE f,
          s_int     TYPE t_int,
          s_int2    TYPE t_int,
          s_packed  TYPE t_packed,
          s_packed2 TYPE t_packed,
          s_numc    TYPE t_numc,
          s_numc2   TYPE t_numc.

*   Integer
    s_int-i = 10.
    json_doc = zcl_json_document_3=&gt;create_with_data( s_int ).
    json_str = json_doc-&gt;get_json( ).
    cl_aunit_assert=&gt;assert_equals( exp = &apos;{&quot;i&quot; :10}&apos;
                                    act = json_str ).
    json_doc2 = zcl_json_document_3=&gt;create_with_json( json_str ).
    json_doc2-&gt;get_data( IMPORTING data = s_int2 ).
    cl_aunit_assert=&gt;assert_equals( exp = s_int
                                    act = s_int2 ).

*   Packed number
    tfloat = &apos;10.5&apos;.
    s_packed-p = tfloat.  &quot;conversion
    json_doc = zcl_json_document_3=&gt;create_with_data( s_packed ).
    json_str = json_doc-&gt;get_json( ).

    cl_aunit_assert=&gt;assert_equals( exp = &apos;{&quot;p&quot; :10.50}&apos;
                                    act = json_str ).
    json_doc2 = zcl_json_document_3=&gt;create_with_json( json_str ).
    json_doc2-&gt;get_data( IMPORTING data = s_packed2 ).
    cl_aunit_assert=&gt;assert_equals( exp = s_packed
                                    act = s_packed2 ).

*   NUMC without leading zeros
    s_numc-nc = &apos;10&apos;.
    json_doc = zcl_json_document_3=&gt;create_with_data( s_numc ).
    json_str = json_doc-&gt;get_json( ).

    cl_aunit_assert=&gt;assert_equals( exp = &apos;{&quot;nc&quot; :&quot;0010&quot;}&apos;
                                    act = json_str ).
    json_doc2 = zcl_json_document_3=&gt;create_with_json( json_str ).
    json_doc2-&gt;get_data( IMPORTING data = s_numc2 ).
    cl_aunit_assert=&gt;assert_equals( exp = s_numc
                                    act = s_numc2 ).

    json_doc = zcl_json_document_3=&gt;create_with_data(
               data             = s_numc
               numc_as_numeric  = abap_true
           ).
    json_str = json_doc-&gt;get_json( ).
    cl_aunit_assert=&gt;assert_equals( exp = &apos;{&quot;nc&quot; :10}&apos;
                                    act = json_str ).
    json_doc2 = zcl_json_document_3=&gt;create_with_json( json_str ).
    json_doc2-&gt;get_data( IMPORTING data = s_numc2 ).
    cl_aunit_assert=&gt;assert_equals( exp = s_numc
                                    act = s_numc2 ).

*   NUMC with leading zeros
    s_numc-nc = &apos;0010&apos;.
    json_doc = zcl_json_document_3=&gt;create_with_data( s_numc ).
    json_str = json_doc-&gt;get_json( ).

    cl_aunit_assert=&gt;assert_equals( exp = &apos;{&quot;nc&quot; :&quot;0010&quot;}&apos;
                                    act = json_str ).
    json_doc2 = zcl_json_document_3=&gt;create_with_json( json_str ).
    json_doc2-&gt;get_data( IMPORTING data = s_numc2 ).
    cl_aunit_assert=&gt;assert_equals( exp = s_numc
                                    act = s_numc2 ).

    json_doc = zcl_json_document_3=&gt;create_with_data(
               data             = s_numc
               numc_as_numeric  = abap_true
           ).
    json_str = json_doc-&gt;get_json( ).
    cl_aunit_assert=&gt;assert_equals( exp = &apos;{&quot;nc&quot; :10}&apos;
                                    act = json_str ).
    json_doc2 = zcl_json_document_3=&gt;create_with_json( json_str ).
    json_doc2-&gt;get_data( IMPORTING data = s_numc2 ).
    cl_aunit_assert=&gt;assert_equals( exp = s_numc
                                    act = s_numc2 ).

  ENDMETHOD.                    &quot;test_number_struct


  METHOD test_append_data.
    DATA: s_int    TYPE t_int,
          s_string TYPE t_string.

    s_int-i = 10.
    s_string-s = &apos;abc&apos;.

    json_doc = zcl_json_document_3=&gt;create( ).
    json_doc-&gt;append_data( data = s_int iv_name = &apos;s_int&apos; ).
    json_doc-&gt;append_data( data = s_string iv_name = &apos;s_string&apos; ).
    json_str = json_doc-&gt;get_json( ).
    cl_aunit_assert=&gt;assert_equals(
        exp = &apos;{&quot;s_int&quot;:{&quot;i&quot; :10}, &quot;s_string&quot;:{&quot;s&quot; :&quot;abc&quot;}}&apos;
        act = json_str ).

  ENDMETHOD.                    &quot;test_append_data

  METHOD test_stru_table.

    DATA: str     TYPE t_string,
          strtab  TYPE TABLE OF t_string,
          strtab2 TYPE TABLE OF t_string.

    str-s = &apos;0010&apos;. APPEND str TO strtab.
    str-s = &apos;00xx&apos;. APPEND str TO strtab.
    str-s = &apos;0030&apos;. APPEND str TO strtab.

    json_doc = zcl_json_document_3=&gt;create_with_data( data = strtab suppress_itab = &apos;X&apos; ).
    json_str = json_doc-&gt;get_json( ).
    cl_aunit_assert=&gt;assert_equals( exp = &apos;[{&quot;s&quot; :&quot;0010&quot;},{&quot;s&quot; :&quot;00xx&quot;},{&quot;s&quot; :&quot;0030&quot;}]&apos;
                                    act = json_str ).
    json_doc2 = zcl_json_document_3=&gt;create_with_json( json_str ).
    json_doc2-&gt;get_data( IMPORTING data = strtab2 ).
    cl_aunit_assert=&gt;assert_equals( exp = strtab
                                    act = strtab2 ).

  ENDMETHOD.                    &quot;test_stru_table

  METHOD test_stru_table_named.

    DATA: str     TYPE t_string,
          strtab  TYPE TABLE OF t_string,
          strtab2 TYPE TABLE OF t_string.

    str-s = &apos;0010&apos;. APPEND str TO strtab.
    str-s = &apos;00xx&apos;. APPEND str TO strtab.
    str-s = &apos;0030&apos;. APPEND str TO strtab.

    json_doc = zcl_json_document_3=&gt;create( ).
    json_doc-&gt;append_data( data = strtab
                           iv_name = &apos;dataname&apos; ).
    json_str = json_doc-&gt;get_json( ).
    cl_aunit_assert=&gt;assert_equals( exp = &apos;{&quot;dataname&quot;: [{&quot;s&quot; :&quot;0010&quot;},{&quot;s&quot; :&quot;00xx&quot;},{&quot;s&quot; :&quot;0030&quot;}]}&apos;
                                    act = json_str ).

  ENDMETHOD.                    &quot;test_stru_table_named

  METHOD test_parse_list_strings.
    DATA: json_input TYPE string,
          has_next   TYPE boolean.

    json_input = &apos;[&quot;value1&quot;,&quot;value2&quot;,&quot;value3&quot;]&apos;.
    json_doc = zcl_json_document_3=&gt;create_with_json( json_input ).
    json_doc-&gt;get_next( ).
    json_str = json_doc-&gt;get_array_value( ).
    cl_aunit_assert=&gt;assert_equals( exp = &apos;value1&apos;
                                    act = json_str ).
    json_doc-&gt;get_next( ).
    json_str = json_doc-&gt;get_array_value( ).
    cl_aunit_assert=&gt;assert_equals( exp = &apos;value2&apos;
                                    act = json_str ).
    json_doc-&gt;get_next( ).
    json_str = json_doc-&gt;get_array_value( ).
    cl_aunit_assert=&gt;assert_equals( exp = &apos;value3&apos;
                                    act = json_str ).
    has_next = json_doc-&gt;get_next( ).
    cl_aunit_assert=&gt;assert_equals( exp = &apos;&apos;
                                    act = has_next ).
  ENDMETHOD.                    &quot;test_parse_list_strings

  METHOD test_parse_flat_object.
    DATA: json_input TYPE string,
          input_stru TYPE t_struc1,
          ref_stru   TYPE t_struc1.

    json_input = &apos;{&quot;i&quot;:22,&quot;nc&quot;:20,&quot;c1&quot;:&quot;X&quot;,&quot;c20&quot;:&quot;test&quot;,&quot;s&quot;:&quot;string test&quot;,&quot;p&quot;:20.5}&apos;.
    ref_stru-i = 22.
    ref_stru-nc = 20.
    ref_stru-c1 = &apos;X&apos;.
    ref_stru-c20 = &apos;test&apos;.
    ref_stru-s = &apos;string test&apos;.
    ref_stru-p = &apos;20.5&apos;.

    json_doc = zcl_json_document_3=&gt;create_with_json( json_input ).
    json_doc-&gt;get_data( IMPORTING data = input_stru ).

    cl_aunit_assert=&gt;assert_equals( exp = ref_stru
                                    act = input_stru ).

    &quot;test starting from a structure and getting the structure in the end
    CLEAR input_stru.
    json_doc = zcl_json_document_3=&gt;create_with_data( ref_stru ).
    json_doc-&gt;get_data( IMPORTING data = input_stru ).

    cl_aunit_assert=&gt;assert_equals( exp = ref_stru
                                    act = input_stru ).

  ENDMETHOD.                    &quot;test_parse_flat_object

  METHOD test_date_format.

    DATA input_stru TYPE t_date.
    DATA ref_stru   TYPE t_date.
    DATA json       TYPE string.

    input_stru-d = &apos;20120927&apos;.
    json_doc = zcl_json_document_3=&gt;create( ).

    &quot;*--- test standard JSON date format ---*
    json_doc-&gt;set_data( input_stru ).
    json = json_doc-&gt;get_json( ).

    cl_aunit_assert=&gt;assert_equals( exp = &apos;{&quot;d&quot; :&quot;20120927&quot;}&apos;
                                    act = json ).

    &quot;*--- test SUP date format ---*
    json_doc-&gt;set_data(
        data          = input_stru
        date_format   = &apos;YYYY-MM-DD&apos;
    ).

    json = json_doc-&gt;get_json( ).

    cl_aunit_assert=&gt;assert_equals( exp = &apos;{&quot;d&quot; :&quot;2012-09-27&quot;}&apos;
                                    act = json ).

    &quot;*--- test world date format ---*
    json_doc-&gt;set_data(
        data          = input_stru
        date_format   = &apos;DD.MM.YYYY&apos;
    ).

    json = json_doc-&gt;get_json( ).

    cl_aunit_assert=&gt;assert_equals( exp = &apos;{&quot;d&quot; :&quot;27.09.2012&quot;}&apos;
                                    act = json ).

    &quot;*--- test US date format ---*
    json_doc-&gt;set_data(
        data          = input_stru
        date_format   = &apos;MM/DD/YYYY&apos;
    ).

    json = json_doc-&gt;get_json( ).

    cl_aunit_assert=&gt;assert_equals( exp = &apos;{&quot;d&quot; :&quot;09/27/2012&quot;}&apos;
                                    act = json ).

    &quot;*--- test short date format ---*
    json_doc-&gt;set_data(
        data          = input_stru
        date_format   = &apos;DDMMYY&apos;
    ).

    json = json_doc-&gt;get_json( ).

    cl_aunit_assert=&gt;assert_equals( exp = &apos;{&quot;d&quot; :&quot;270912&quot;}&apos;
                                    act = json ).

  ENDMETHOD.                    &quot;test_date_format

  METHOD test_date_format_reverse.

    DATA input_stru TYPE t_date.
    DATA ref_stru   TYPE t_date.
    DATA json       TYPE string.

    input_stru-d = &apos;20120927&apos;.
    json_doc = zcl_json_document_3=&gt;create( ).

    &quot;*--- test standard JSON date format ---*
    json = &apos;{&quot;d&quot; :&quot;20120927&quot;}&apos;.
    json_doc-&gt;set_json( json ).

    json_doc-&gt;get_data(
      IMPORTING
        data = ref_stru
    ).

    cl_aunit_assert=&gt;assert_equals( exp = input_stru
                                    act = ref_stru ).

    &quot;*--- test SUP date format ---*
    json = &apos;{&quot;d&quot; :&quot;2012-09-27&quot;}&apos;.
    json_doc-&gt;set_json(
      EXPORTING
        json        = json
        date_format = &apos;YYYY-MM-DD&apos;
    ).

    json_doc-&gt;get_data(
      IMPORTING
        data = ref_stru
    ).

    cl_aunit_assert=&gt;assert_equals( exp = input_stru
                                    act = ref_stru ).

    &quot;*--- test world date format ---*
    json = &apos;{&quot;d&quot; :&quot;27.09.2012&quot;}&apos;.
    json_doc-&gt;set_json(
      EXPORTING
        json        = json
        date_format = &apos;DD.MM.YYYY&apos;
    ).

    json_doc-&gt;get_data(
      IMPORTING
        data = ref_stru
    ).

    cl_aunit_assert=&gt;assert_equals( exp = input_stru
                                    act = ref_stru ).

    &quot;*--- test US date format ---*
    json = &apos;{&quot;d&quot; :&quot;09/27/2012&quot;}&apos;.
    json_doc-&gt;set_json(
      EXPORTING
        json        = json
        date_format = &apos;MM/DD/YYYY&apos;
    ).

    json_doc-&gt;get_data(
      IMPORTING
        data = ref_stru
    ).

    cl_aunit_assert=&gt;assert_equals( exp = input_stru
                                    act = ref_stru ).


  ENDMETHOD.                    &quot;test_date_format_reverse

  METHOD test_namespace.

    DATA input_stru TYPE t_namespace.
    DATA json       TYPE string.

    input_stru-/cex/test = &apos;with namespace&apos;.
    input_stru-test = &apos;without namespace&apos;.

    json_doc = zcl_json_document_3=&gt;create( ).

    &quot;*--- regular namespace ---*
    json_doc-&gt;set_data( input_stru ).
    json = json_doc-&gt;get_json( ).

    cl_aunit_assert=&gt;assert_equals( exp = &apos;{&quot;/cex/test&quot; :&quot;with namespace&quot;,&quot;test&quot; :&quot;without namespace&quot;}&apos;
                                    act = json ).

    &quot;*--- replace namespace ---*
    json_doc-&gt;set_namespace_conversion(
      EXPORTING
        namespace_1_slash_replace = &apos;&apos;
        namespace_2_slash_replace = &apos;_&apos;
    ).

    json_doc-&gt;set_data( input_stru ).
    json = json_doc-&gt;get_json( ).

    cl_aunit_assert=&gt;assert_equals( exp = &apos;{&quot;cex_test&quot; :&quot;with namespace&quot;,&quot;test&quot; :&quot;without namespace&quot;}&apos;
                                    act = json ).

  ENDMETHOD.                    &quot;test_namespace


  METHOD test_xstring.

    DATA input_stru TYPE t_struc1.
    DATA ref_stru   TYPE t_struc1.
    DATA json       TYPE string.

    input_stru-x = &apos;00AABB&apos;.
    json_doc = zcl_json_document_3=&gt;create_with_data( input_stru ).

    json = json_doc-&gt;get_json( ).

    json_doc-&gt;set_json( json ).

    json_doc-&gt;get_data(
      IMPORTING
        data = ref_stru
    ).

    cl_aunit_assert=&gt;assert_equals( exp = input_stru
                                    act = ref_stru ).

  ENDMETHOD.                    &quot;test_xstring

  METHOD test_dref.

    DATA input_stru TYPE t_struc1.
    DATA ref_stru   TYPE t_struc1.
    DATA json       TYPE string.

    FIELD-SYMBOLS &lt;inp&gt; TYPE string.
    FIELD-SYMBOLS &lt;ref&gt; TYPE string.

    CREATE DATA input_stru-dr TYPE string.
    ASSIGN input_stru-dr-&gt;* TO &lt;inp&gt;.
    &lt;inp&gt; = &apos;Dref string&apos;.

    json_doc = zcl_json_document_3=&gt;create_with_data( input_stru ).

    json = json_doc-&gt;get_json( ).

    json_doc-&gt;set_json( json ).

    json_doc-&gt;get_data(
      IMPORTING
        data = ref_stru
    ).

    ASSIGN ref_stru-dr-&gt;* TO &lt;ref&gt;.

    IF &lt;ref&gt; IS NOT ASSIGNED.
      cl_abap_unit_assert=&gt;assert_equals( msg = &apos;Field-Symbol not assigned&apos; exp = 1 act = 2 ).
    ELSE.
      cl_aunit_assert=&gt;assert_equals( exp = &lt;inp&gt;
                                      act = &lt;ref&gt; ).
    ENDIF.


  ENDMETHOD.                    &quot;test_dref

  METHOD test_boolean.

    DATA: BEGIN OF ls_test,
            yyy TYPE boolean,
            xxx TYPE boolean,
          END OF ls_test.

    DATA: ls_test_ref LIKE ls_test.
    DATA: json TYPE string.

    ls_test-xxx = abap_true.

    json_doc = zcl_json_document_3=&gt;create_with_data( ls_test ).
    json = json_doc-&gt;get_json( ).

    cl_aunit_assert=&gt;assert_equals( exp = &apos;{&quot;yyy&quot; :false,&quot;xxx&quot; :true}&apos;
                                    act = json ).

    json_doc-&gt;get_data(
      EXPORTING
        json              = json
      IMPORTING
        data              = ls_test_ref
    ).

    cl_aunit_assert=&gt;assert_equals( exp = ls_test
                                    act = ls_test_ref ).

    json_doc = zcl_json_document_3=&gt;create_with_data(
                     data             = ls_test
                     ignore_boolean   = abap_true
                 ).

    json = json_doc-&gt;get_json( ).
    cl_aunit_assert=&gt;assert_equals( exp = &apos;{&quot;yyy&quot; :&quot;&quot;,&quot;xxx&quot; :&quot;X&quot;}&apos;
                                    act = json ).

  ENDMETHOD.


  METHOD test_transform_simple.

    DATA: BEGIN OF ls_test,
            yyy TYPE string,
            xxx TYPE n LENGTH 3,
          END OF ls_test.

    DATA: ls_test_ref LIKE ls_test.
    DATA: json TYPE string.

    ls_test-yyy = &apos;Field 1&apos;.
    ls_test-xxx = &apos;123&apos;.

    zcl_json_document_3=&gt;transform_simple(
      EXPORTING
        data_in              = ls_test
      IMPORTING
        json_out             = json
    ).

    cl_aunit_assert=&gt;assert_equals( exp = &apos;{&quot;RESULT&quot;:{&quot;YYY&quot;:&quot;Field 1&quot;,&quot;XXX&quot;:&quot;123&quot;}}&apos;
                                    act = json ).

    zcl_json_document_3=&gt;transform_simple(
      EXPORTING
        json_in              = json
      IMPORTING
        data_out             = ls_test_ref
    ).

    cl_aunit_assert=&gt;assert_equals( exp = ls_test
                                    act = ls_test_ref ).

    zcl_json_document_3=&gt;transform_simple(
      EXPORTING
        data_in              = ls_test
        lower_case           = abap_true
      IMPORTING
        json_out             = json
    ).

    cl_aunit_assert=&gt;assert_equals( exp = &apos;{&quot;result&quot;:{&quot;yyy&quot;:&quot;Field 1&quot;,&quot;xxx&quot;:&quot;123&quot;}}&apos;
                                    act = json ).

    CLEAR ls_test_ref.

    zcl_json_document_3=&gt;transform_simple(
      EXPORTING
        json_in              = json
        lower_case           = abap_true
      IMPORTING
        data_out             = ls_test_ref
    ).

    cl_aunit_assert=&gt;assert_equals( exp = ls_test
                                    act = ls_test_ref ).

  ENDMETHOD.

  METHOD test_name_values.

    DATA json TYPE string.
    DATA name_values TYPE wdy_key_value_list .
    FIELD-SYMBOLS: &lt;name_value&gt; TYPE wdy_key_value .

    json_doc = zcl_json_document_3=&gt;create_with_json( &apos;{ &quot;foo&quot;:&quot;bar&quot;, &quot;foo2&quot;:&quot;bar2&quot; }&apos; ).
    json_doc-&gt;get_name_value_pairs(
      IMPORTING
        name_values = name_values
    ).

    READ TABLE name_values WITH KEY key = &apos;foo&apos; ASSIGNING &lt;name_value&gt;.

    IF &lt;name_value&gt; IS NOT ASSIGNED.
      cl_abap_unit_assert=&gt;assert_equals( msg = &apos;Field-Symbol not assigned&apos; exp = 1 act = 2 ).
    ELSE.
      cl_aunit_assert=&gt;assert_equals( exp = &apos;bar&apos;
                                      act = &lt;name_value&gt;-value ).
    ENDIF.

    READ TABLE name_values WITH KEY key = &apos;foo2&apos; ASSIGNING &lt;name_value&gt;.
    IF &lt;name_value&gt; IS NOT ASSIGNED.
      cl_abap_unit_assert=&gt;assert_equals( msg = &apos;Field-Symbol not assigned&apos; exp = 1 act = 2 ).
    ELSE.
      cl_aunit_assert=&gt;assert_equals( exp = &apos;bar2&apos;
                                      act = &lt;name_value&gt;-value ).
    ENDIF.

    json_doc-&gt;set_name_value_pairs( name_values ).
    json = json_doc-&gt;get_json( ).

    cl_aunit_assert=&gt;assert_equals( exp = &apos;{&quot;foo&quot; :&quot;bar&quot;,&quot;foo2&quot; :&quot;bar2&quot; }&apos;
                                    act = json ).

  ENDMETHOD.

ENDCLASS.                    &quot;lcl_zjson IMPLEMENTATION</localImplementation>
 <localTypes>*&quot;* use this source file for any type of declarations (class
*&quot;* definitions, interfaces or type declarations) you need for
*&quot;* components in the private section</localTypes>
 <localMacros>*&quot;* use this source file for any macro definitions you need
*&quot;* in the implementation part of the class</localMacros>
 <localTestClasses>*&quot;* use this source file for your ABAP unit test classes</localTestClasses>
 <typeUsage CLSNAME="ZCL_JSON_DOCUMENT_3" TYPEGROUP="ABAP" VERSION="1" TPUTYPE="0" EXPLICIT="X" IMPLICIT="X"/>
 <forwardDeclaration>ABAP</forwardDeclaration>
 <attribute CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="ARRAY_CURSOR" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="7 " ATTDECLTYP="0" ATTVALUE="-1" ATTEXPVIRT="0" TYPTYPE="1" TYPE="I" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
 <attribute CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="ARRAY_CURSOR_MAX" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="8 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="I" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
 <attribute CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="ARRAY_PROPERTY_PATH" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="6 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
 <attribute CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="DATE_FORMAT" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="15 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="CHAR10" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
 <attribute CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="DONT_ESCAPE_LTGT" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="12 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="BOOLEAN" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
 <attribute CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="DONT_REPLACE_LINEBREAKS" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="14 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="BOOLEAN" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
 <attribute CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="IGNORE_BOOLEAN" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="11 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="BOOLEAN" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
 <attribute CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="JS" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="2 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="3" TYPE="CL_JAVA_SCRIPT" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
 <attribute CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="JSON" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="1 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
 <attribute CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="JS_PROPERTY_PATH" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="3 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
 <attribute CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="JS_PROPERTY_STRING_TABLE" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="5 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="JS_PROPERTY_TAB" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
 <attribute CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="JS_PROPERTY_TABLE" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="4 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="JS_PROPERTY_TAB" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
 <attribute CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="NAMESPACE_REPLACE_PATTERN" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="16 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="STRING" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
 <attribute CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="NUMC_AS_NUMERIC" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="13 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="BOOLEAN" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
 <attribute CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="OBJECT_ADDED" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="9 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="BOOLEAN" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
 <attribute CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="SUPPRESS_ITAB" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="10 " ATTDECLTYP="0" ATTEXPVIRT="0" TYPTYPE="1" TYPE="BOOLEAN" SRCROW1="0 " SRCCOLUMN1="0 " SRCROW2="0 " SRCCOLUMN2="0 " TYPESRC_LENG="0 "/>
 <method CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="ADD_BOOLEAN" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="5 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="ADD_BOOLEAN" SCONAME="STRING" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
  <source>METHOD add_boolean.

    IF string = abap_true.
      CONCATENATE
        json
        &apos;true&apos;
      INTO json.
    ELSE.
      CONCATENATE
        json
        &apos;false&apos;
      INTO json.
    ENDIF.

  ENDMETHOD.</source>
 </method>
 <method CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="ADD_DATA" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="ADD_DATA" SCONAME="DATA" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
  <source>METHOD add_data.

    DATA: data_descr TYPE REF TO cl_abap_datadescr.

    data_descr ?= cl_abap_typedescr=&gt;describe_by_data( data ).

    CASE data_descr-&gt;type_kind.
      WHEN data_descr-&gt;typekind_table.       &quot;table

        add_table( data ).

      WHEN data_descr-&gt;typekind_struct1     &quot;flat strcuture
      OR   data_descr-&gt;typekind_struct2.     &quot;deep strcuture

        add_stru( data ).

      WHEN data_descr-&gt;typekind_char
      OR   data_descr-&gt;typekind_string
      OR   data_descr-&gt;typekind_clike
      OR   data_descr-&gt;typekind_csequence.

        IF data_descr-&gt;absolute_name = &apos;\TYPE=BOOLEAN&apos;
        AND me-&gt;ignore_boolean IS INITIAL.
          add_boolean( data ).
        ELSE.
          add_string( data ).
        ENDIF.

      WHEN data_descr-&gt;typekind_num.          &quot;charlike incl. NUMC.

        IF me-&gt;numc_as_numeric IS INITIAL.
          add_string( data ).
        ELSE.
          add_number( data ).
        ENDIF.

      WHEN data_descr-&gt;typekind_int
      OR   data_descr-&gt;typekind_int1
      OR   data_descr-&gt;typekind_int2
      OR   data_descr-&gt;typekind_packed.

        add_number( data ).

      WHEN data_descr-&gt;typekind_date.

        add_date( data ).

      WHEN data_descr-&gt;typekind_time.

        add_time( data ).

      WHEN data_descr-&gt;typekind_xstring.

        add_xstring( data ).

      WHEN data_descr-&gt;typekind_dref.
        FIELD-SYMBOLS &lt;any&gt; TYPE data.

        IF data IS BOUND.
          ASSIGN data-&gt;* TO &lt;any&gt;.
          add_data( &lt;any&gt; ).
        ELSE.
          add_string( `` ).
        ENDIF.

      WHEN data_descr-&gt;typekind_hex.      &quot;RAW (ie. GUID)

        DATA: str_data TYPE char512.
        TRY.
            WRITE data TO str_data.
            add_string( str_data ).
          CATCH cx_root.
            add_string( `` ).
        ENDTRY.

*    WHEN data_descr-&gt;typekind_float.
*    WHEN data_descr-&gt;typekind_w.
*    WHEN data_descr-&gt;typekind_oref.
*    WHEN data_descr-&gt;typekind_class.
*    WHEN data_descr-&gt;typekind_intf.
*    WHEN data_descr-&gt;typekind_any.
*    WHEN data_descr-&gt;typekind_data.
*    WHEN data_descr-&gt;typekind_simple.
*    WHEN data_descr-&gt;typekind_xsequence.
*    WHEN data_descr-&gt;typekind_numeric.
*    WHEN data_descr-&gt;typekind_table.
*    WHEN data_descr-&gt;typekind_iref.

*    WHEN OTHERS.

    ENDCASE.

  ENDMETHOD.</source>
 </method>
 <method CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="ADD_DATE" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="ADD_DATE" SCONAME="DATE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="D"/>
  <source>METHOD add_date.

    DATA: lv_date_c TYPE c LENGTH 10.

    lv_date_c = format_date( date ).

    CONCATENATE
      json
      &apos;&quot;&apos;
      lv_date_c
      &apos;&quot;&apos;
    INTO json.

  ENDMETHOD.</source>
 </method>
 <method CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="ADD_NUMBER" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="ADD_NUMBER" SCONAME="NUMBER" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
  <source>METHOD add_number.

    DATA: lv_num_c TYPE c LENGTH 30.

    lv_num_c = number.

    &quot;*--- sign on the left ---*
    IF lv_num_c CS &apos;-&apos;.
      SHIFT lv_num_c RIGHT UP TO &apos;-&apos;.
      SHIFT lv_num_c CIRCULAR RIGHT.
    ENDIF.

    &quot;*--- store NUMC without leading zero (sapcodexch #issue 17) ---*
    SHIFT lv_num_c LEFT DELETING LEADING &apos;0&apos;.

    &quot;*--- if all numbers are deleted, set lv_num_c to zero
    IF lv_num_c IS INITIAL.
      lv_num_c = &apos;0&apos;.
    ENDIF.

    CONDENSE lv_num_c NO-GAPS.

    CONCATENATE
      json
      lv_num_c
    INTO json.

  ENDMETHOD.</source>
 </method>
 <method CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="ADD_STRING" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="ADD_STRING" SCONAME="STRING" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
  <source>METHOD add_string.

    DATA: lv_string TYPE string.

    &quot;*--- JSON conform conversion ---*
    &quot;*--- sapcodexch issue #4 ---*
    lv_string = string.   &quot;convert to string
    lv_string = cl_http_utility=&gt;if_http_utility~escape_javascript( lv_string ).

    &quot;*--- don&apos;t escape single quotes ---*
    &quot;*--- sapcodexch issue #11 ---*
    REPLACE ALL OCCURRENCES OF &apos;\&apos;&apos;&apos; IN lv_string WITH &apos;&apos;&apos;&apos;.

    &quot;*--- don&apos;t escape LT / GT ? ---*
    IF me-&gt;dont_escape_ltgt = abap_true.
      REPLACE ALL OCCURRENCES OF &apos;\x3c&apos; IN lv_string WITH &apos;&lt;&apos;.
      REPLACE ALL OCCURRENCES OF &apos;\x3e&apos; IN lv_string WITH &apos;&gt;&apos;.
    ENDIF.

    CONCATENATE
      json
      &apos;&quot;&apos;
      lv_string
      &apos;&quot;&apos;
    INTO json.

  ENDMETHOD.</source>
 </method>
 <method CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="ADD_STRU" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="6 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="ADD_STRU" SCONAME="LINE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
  <source>METHOD add_stru.

    DATA: stru_descr       TYPE REF TO cl_abap_structdescr
        , lv_tabix         TYPE sy-tabix
        , comp_name        TYPE abap_compname
        , use_parameter_id TYPE boolean
        .

    FIELD-SYMBOLS: &lt;value&gt; TYPE any
                 , &lt;component&gt; TYPE abap_compdescr
                 .

    DATA lv_parameter_id TYPE string.

    stru_descr ?= cl_abap_typedescr=&gt;describe_by_data( line ).

    CONCATENATE
      json
      &apos;{&apos;
    INTO json.

    LOOP AT stru_descr-&gt;components
      ASSIGNING &lt;component&gt;.

      lv_tabix = sy-tabix.

      ASSIGN COMPONENT &lt;component&gt;-name OF STRUCTURE line TO &lt;value&gt;.

      comp_name = &lt;component&gt;-name.
      TRANSLATE comp_name TO LOWER CASE.

      replace_namespace( CHANGING key = comp_name ).

      IF comp_name = &apos;parameter_id&apos;.
        lv_parameter_id = &lt;value&gt;.                            &quot;&lt;= 7.01
        use_parameter_id = abap_true.
        CONTINUE.
      ELSEIF comp_name = &apos;data&apos;.
        IF use_parameter_id IS NOT INITIAL.
          comp_name = lv_parameter_id.
          CLEAR use_parameter_id.
        ENDIF.
      ENDIF.

      CONCATENATE
        json
        &apos;&quot;&apos;
        comp_name
        &apos;&quot; :&apos;
      INTO json.

      add_data( &lt;value&gt; ).

      IF lv_tabix &lt;&gt; lines( stru_descr-&gt;components ).
        CONCATENATE
          json
          &apos;,&apos;
        INTO json.
      ENDIF.

    ENDLOOP.

    CONCATENATE
      json
      &apos;}&apos;
    INTO json.

  ENDMETHOD.</source>
 </method>
 <method CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="ADD_TABLE" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="7 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="ADD_TABLE" SCONAME="TABLE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY TABLE"/>
  <source>METHOD add_table.

    DATA lv_tabix TYPE sytabix.
    FIELD-SYMBOLS: &lt;line&gt; TYPE any.

    DATA lv_end TYPE boolean.

    IF strlen( json ) &gt; 3
    OR suppress_itab = abap_true. &quot;sapcodexch issue #13
      CONCATENATE
        json
        &apos; [&apos;
      INTO json.
    ELSE.
      lv_end = abap_true.
      CONCATENATE
        json
        &apos;{ &quot;itab&quot; : [&apos;
      INTO json.
    ENDIF.

    LOOP AT table
      ASSIGNING &lt;line&gt;.

      lv_tabix = sy-tabix.

      add_data( &lt;line&gt; ).

      IF lv_tabix &lt;&gt; lines( table ).
        CONCATENATE
          json
          &apos;,&apos;
        INTO json.
      ENDIF.

    ENDLOOP.

    IF lv_end = abap_true.
      CONCATENATE
        json
        &apos;] }&apos;
      INTO json.
    ELSE.
      CONCATENATE
        json
        &apos;]&apos;
      INTO json.
    ENDIF.

  ENDMETHOD.</source>
 </method>
 <method CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="ADD_TIME" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="8 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="ADD_TIME" SCONAME="TIME" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="T"/>
  <source>METHOD add_time.

    DATA: lv_time_c TYPE c LENGTH 8.

    CONCATENATE
      time(2)
      &apos;:&apos;
      time+2(2)
      &apos;:&apos;
      time+4(2)
    INTO lv_time_c.

    CONCATENATE
      json
      &apos;&quot;&apos;
      lv_time_c
      &apos;&quot;&apos;
    INTO json.

  ENDMETHOD.</source>
 </method>
 <method CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="ADD_XSTRING" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="9 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="ADD_XSTRING" SCONAME="XSTRING" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
  <source>METHOD add_xstring.

    DATA: lv_string TYPE string.

*  lv_string = cl_http_utility=&gt;encode_x_base64( xstring ) .  &quot;&gt;= 7.02

    &quot;*--- &lt;= 7.01 ---*
    DATA: c_last_error TYPE i.
    DATA: ihttp_scid_base64_escape_x TYPE i VALUE 86.

    SYSTEM-CALL ict
      DID
        ihttp_scid_base64_escape_x
      PARAMETERS
        xstring                            &quot; &gt;
        lv_string                          &quot; &lt;
        c_last_error.                      &quot; &lt; return code

    CONCATENATE
      json
      &apos;&quot;&apos;
      lv_string
      &apos;&quot;&apos;
    INTO json.

  ENDMETHOD.</source>
 </method>
 <method CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="APPEND_DATA" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="4 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="APPEND_DATA" SCONAME="DATA" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="APPEND_DATA" SCONAME="IV_NAME" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
  <source>METHOD append_data.

    IF json IS INITIAL.
*    json =  | &quot;{ iv_name }&quot;:|.                             &quot;&gt;= 7.02

      CONCATENATE                                             &quot;&lt;= 7.01
        &apos;&quot;&apos;
        iv_name
        &apos;&quot;:&apos;
      INTO json.

    ELSE.
*    json = json &amp;&amp; |, &quot;{ iv_name }&quot;:|.                     &quot;&gt;= 7.02

      CONCATENATE                                             &quot;&lt;= 7.01
        json
        &apos;, &quot;&apos;
        iv_name
        &apos;&quot;:&apos;
      INTO json.

    ENDIF.

    add_data( data ).

  ENDMETHOD.</source>
 </method>
 <method CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="CLEAR" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="17 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <source>METHOD clear.
    CLEAR me-&gt;json.
  ENDMETHOD.</source>
 </method>
 <method CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="CREATE" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="1 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="CREATE" SCONAME="JSON_DOCUMENT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_JSON_DOCUMENT_3"/>
  <source>METHOD create.
    CREATE OBJECT json_document.
  ENDMETHOD.</source>
 </method>
 <method CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="CREATE_WITH_DATA" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="2 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="CREATE_WITH_DATA" SCONAME="DATA" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="CREATE_WITH_DATA" SCONAME="SUPPRESS_ITAB" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="BOOLEAN" PAROPTIONL="X"/>
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="CREATE_WITH_DATA" SCONAME="IGNORE_BOOLEAN" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="BOOLEAN" PAROPTIONL="X"/>
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="CREATE_WITH_DATA" SCONAME="DONT_ESCAPE_LTGT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="BOOLEAN" PAROPTIONL="X"/>
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="CREATE_WITH_DATA" SCONAME="NUMC_AS_NUMERIC" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="BOOLEAN" PAROPTIONL="X"/>
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="CREATE_WITH_DATA" SCONAME="DATE_FORMAT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="6 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CHAR10" PAROPTIONL="X"/>
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="CREATE_WITH_DATA" SCONAME="JSON_DOCUMENT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="7 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_JSON_DOCUMENT_3"/>
  <exception CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="CREATE_WITH_DATA" SCONAME="ZCX_JSON_DOCUMENT_3" VERSION="1" LANGU="E" MTDTYPE="0" EDITORDER="1 "/>
  <source>METHOD create_with_data.

    CREATE OBJECT json_document.

    json_document-&gt;set_data(
      data             = data
      suppress_itab    = suppress_itab
      ignore_boolean   = ignore_boolean
      dont_escape_ltgt = dont_escape_ltgt
      numc_as_numeric  = numc_as_numeric
      date_format      = date_format
      ).

  ENDMETHOD.</source>
 </method>
 <method CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="CREATE_WITH_JSON" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="3 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="CREATE_WITH_JSON" SCONAME="JSON" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="CREATE_WITH_JSON" SCONAME="DATE_FORMAT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CHAR10" PAROPTIONL="X"/>
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="CREATE_WITH_JSON" SCONAME="JSON_DOCUMENT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="3" TYPE="ZCL_JSON_DOCUMENT_3"/>
  <exception CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="CREATE_WITH_JSON" SCONAME="ZCX_JSON_DOCUMENT_3" VERSION="1" LANGU="E" MTDTYPE="0" EDITORDER="1 "/>
  <source>METHOD create_with_json.

    CREATE OBJECT json_document.
    json_document-&gt;set_json(
      EXPORTING
        json        = json
        date_format = date_format
    ).

  ENDMETHOD.</source>
 </method>
 <method CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="FORMAT_DATE" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="13 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="FORMAT_DATE" SCONAME="DATE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="D"/>
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="FORMAT_DATE" SCONAME="DATE_FORMATTED" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="CHAR10"/>
  <source>METHOD format_date.

    DATA: i   TYPE i,
          fmt TYPE c LENGTH 10.

    IF date_format IS INITIAL.
      date_formatted = date.

    ELSE.

      fmt = date_format.

      IF fmt CS &apos;YYYY&apos;.
        WRITE date(4) TO date_formatted+sy-fdpos(4).
      ELSEIF fmt CS &apos;YY&apos;.
        WRITE date+2(2) TO date_formatted+sy-fdpos(2).
      ENDIF.
      IF fmt CS &apos;MM&apos;.
        WRITE date+4(2) TO date_formatted+sy-fdpos(2).
      ENDIF.
      IF fmt CS &apos;DD&apos;.
        WRITE date+6(2) TO date_formatted+sy-fdpos(2).
      ENDIF.

* delimiter
      i = 0.
      WHILE NOT fmt IS INITIAL.
        IF fmt(1) NA &apos;YMD&apos;.
          WRITE fmt(1) TO date_formatted+i(1).
        ENDIF.
        SHIFT fmt LEFT.
        i = i + 1.
      ENDWHILE.

    ENDIF.

  ENDMETHOD.</source>
 </method>
 <method CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="GET_ARRAY_VALUE" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="12 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="GET_ARRAY_VALUE" SCONAME="I_INDEX" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="I" PAROPTIONL="X"/>
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="GET_ARRAY_VALUE" SCONAME="R_VALUE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="STRING"/>
  <source>METHOD get_array_value.

    DATA index_string TYPE string.
    DATA len          TYPE i.

    FIELD-SYMBOLS &lt;line&gt; LIKE LINE OF me-&gt;js_property_string_table.

    IF i_index IS SUPPLIED.
      index_string = i_index.
    ELSE.
      index_string = me-&gt;array_cursor.
    ENDIF.

    len = strlen( index_string ) - 1.
    index_string = index_string(len).

    READ TABLE me-&gt;js_property_string_table
      ASSIGNING &lt;line&gt;
      WITH KEY name = index_string.

    IF sy-subrc = 0.
      r_value = &lt;line&gt;-value.
    ENDIF.

  ENDMETHOD.</source>
 </method>
 <method CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="GET_DATA" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="5 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="GET_DATA" SCONAME="JSON" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING" PAROPTIONL="X"/>
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="GET_DATA" SCONAME="DATA" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
  <exception CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="GET_DATA" SCONAME="ZCX_JSON_DOCUMENT_3" VERSION="1" LANGU="E" MTDTYPE="0" EDITORDER="1 "/>
  <source>METHOD get_data.

    DATA: data_descr TYPE REF TO cl_abap_datadescr.
    DATA: lr_json_doc TYPE REF TO zcl_json_document_3.
    DATA: lv_json TYPE string.
    DATA: tmp TYPE c LENGTH 10.
    DATA: tmp_s TYPE string.
    DATA: lv_submatch TYPE string.
    DATA: lv_len TYPE i.

    DATA: lr_cx_root TYPE REF TO cx_root.
    DATA: lv_error_text TYPE string.
    DATA: lv_type_kind TYPE string.

    IF json IS NOT INITIAL.
      lv_json = json.
    ELSE.
      lv_json = me-&gt;json.
    ENDIF.

    &quot;*--- surrounded object added in SET_JSON? -&gt; delete ---*
    IF me-&gt;object_added = abap_true.
      IF strlen( lv_json ) &gt; 10.
        IF lv_json(10) = &apos;{ &quot;itab&quot; :&apos;.
          SHIFT lv_json CIRCULAR RIGHT UP TO &apos;]&apos;.       &quot;&apos;CIRCULAR&apos; because of STRING
          SHIFT lv_json LEFT UP TO &apos;[&apos;.
        ENDIF.
      ENDIF.
    ENDIF.

    CLEAR data.

    &quot;*--- create new JSON document (recursive!) ---*
    &quot;if we are already on value level, no need to parse again
    IF  lv_json+0(1) NE `{`
    AND lv_json+0(1) NE `[`.
      lr_json_doc = me.
      me-&gt;json = lv_json.
    ELSE.
      lr_json_doc = zcl_json_document_3=&gt;create_with_json(
          json          = lv_json
          date_format   = me-&gt;date_format
      ).
    ENDIF.

    data_descr ?= cl_abap_typedescr=&gt;describe_by_data( data ).

    CASE data_descr-&gt;type_kind.

      WHEN data_descr-&gt;typekind_char         &quot;charlike
      OR   data_descr-&gt;typekind_string
      OR   data_descr-&gt;typekind_clike
      OR   data_descr-&gt;typekind_csequence.

        lr_json_doc-&gt;get_json_large(
          IMPORTING
            json = tmp_s
        ).

        lv_len = data_descr-&gt;length / cl_abap_char_utilities=&gt;charsize.  &quot;length of field (unicode/non-unicode)

        IF  data_descr-&gt;type_kind = data_descr-&gt;typekind_char   &quot;character
        AND lv_len = 1.                                          &quot;length 1

          IF tmp_s = &apos;true&apos;.                                     &quot;-&gt; boolean
            data = abap_true.
          ELSEIF tmp_s = &apos;false&apos;.
            data = abap_false.
          ELSE.
            data = tmp_s.
          ENDIF.

        ELSE.
          data = tmp_s.
        ENDIF.

        &quot;*--- eliminate surrounding &quot; ---*
        FIND REGEX &apos;^&quot;(.{1,})&quot;&apos; IN data     &quot;get 1-n chars surrounded by quot.marks (sapcodexch issue #22)
          SUBMATCHES lv_submatch.

        IF sy-subrc = 0.
          data = lv_submatch.
        ENDIF.

        &quot;*--- unescape control character ---*
        REPLACE ALL OCCURRENCES OF &apos;\&quot;&apos; IN data WITH &apos;&quot;&apos;.
        REPLACE ALL OCCURRENCES OF &apos;\\&apos; IN data WITH &apos;\&apos;.
        REPLACE ALL OCCURRENCES OF &apos;\x3c&apos; IN data WITH &apos;&lt;&apos;.
        REPLACE ALL OCCURRENCES OF &apos;\x3e&apos; IN data WITH &apos;&gt;&apos;.

      WHEN data_descr-&gt;typekind_num          &quot;NUM + integer + packed (auto conversion)
      OR   data_descr-&gt;typekind_int
      OR   data_descr-&gt;typekind_int1
      OR   data_descr-&gt;typekind_int2
      OR   data_descr-&gt;typekind_packed
      OR   data_descr-&gt;typekind_hex.        &quot;RAW (ie. GUID)

        lr_json_doc-&gt;get_json_large(
          IMPORTING
            json = tmp_s
        ).

        TRY.

            IF data_descr-&gt;type_kind &lt;&gt; data_descr-&gt;typekind_hex
            AND tmp_s CS &apos;E&apos;.      &quot;saved as float in JSON string?
              DATA float TYPE f.
              float = tmp_s.
              data = float.
            ELSE.
              data = tmp_s.
            ENDIF.

          CATCH cx_root INTO lr_cx_root.
            lv_error_text = lr_cx_root-&gt;get_text( ).
            lv_type_kind = data_descr-&gt;type_kind.

            RAISE EXCEPTION TYPE zcx_json_document_3
              EXPORTING
                textid       = zcx_json_document_3=&gt;conversation_error
                error_text   = lv_error_text
                type_kind    = lv_type_kind
                actual_value = lv_json.

        ENDTRY.

      WHEN data_descr-&gt;typekind_xstring.

        DATA lv_xstring TYPE xstring.

        lr_json_doc-&gt;get_json_large(
          IMPORTING
            json = tmp_s
        ).

*        data = cl_http_utility=&gt;decode_x_base64( tmp_s ) .  &quot;&gt;= 7.02

        &quot;*--- &lt;= 7.01 ---*
        DATA: c_last_error TYPE i.
        DATA: ihttp_scid_base64_unescape_x TYPE i VALUE 87.

        SYSTEM-CALL ict
          DID
            ihttp_scid_base64_unescape_x
          PARAMETERS
            tmp_s                            &quot; &gt;
            data                            &quot; &lt;
            c_last_error.                      &quot; &lt; return code

      WHEN data_descr-&gt;typekind_time.

        lr_json_doc-&gt;get_json_large(
          IMPORTING
            json = tmp_s
        ).

        REPLACE ALL OCCURRENCES OF &apos;:&apos; IN tmp_s WITH ``.
        data = tmp_s.

      WHEN data_descr-&gt;typekind_struct1     &quot;flat strcuture
      OR   data_descr-&gt;typekind_struct2.     &quot;deep strcuture

        lr_json_doc-&gt;get_stru( CHANGING line = data ).

      WHEN data_descr-&gt;typekind_table.       &quot;table

        lr_json_doc-&gt;get_table( CHANGING table = data ).

      WHEN data_descr-&gt;typekind_date.

        lr_json_doc-&gt;get_json_large(
          IMPORTING
            json = tmp_s
        ).

        tmp = tmp_s.

        IF date_format IS INITIAL.
          data = tmp.
        ELSE.
          IF date_format CS &apos;YYYY&apos;.
            DATA(4) = tmp+sy-fdpos(4).
          ELSE.
            FIND &apos;YY&apos; IN date_format.
            CONCATENATE
              &apos;20&apos;
              tmp+sy-fdpos(2)
            INTO DATA(4).
          ENDIF.

          IF date_format CS &apos;MM&apos;.
            data+4(2) = tmp+sy-fdpos(2).
          ENDIF.

          IF date_format CS &apos;DD&apos;.
            data+6(2) = tmp+sy-fdpos(2).
          ENDIF.

        ENDIF.

      WHEN data_descr-&gt;typekind_dref.

        &quot;*--- as we don&apos;t know the original data type, ---*
        &quot;*--- we always pass back a string dref        ---*
        &quot;*--- (function not really useful)             ---*
        FIELD-SYMBOLS &lt;f&gt; TYPE string.
        CREATE DATA data TYPE string.

        ASSIGN data-&gt;* TO &lt;f&gt;.

        lr_json_doc-&gt;get_json_large(
          IMPORTING
            json = &lt;f&gt;
        ).

        GET REFERENCE OF &lt;f&gt; INTO data.

*    WHEN data_descr-&gt;typekind_float.
*    WHEN data_descr-&gt;typekind_w.
*    WHEN data_descr-&gt;typekind_oref.
*    WHEN data_descr-&gt;typekind_class.
*    WHEN data_descr-&gt;typekind_intf.
*    WHEN data_descr-&gt;typekind_any.
*    WHEN data_descr-&gt;typekind_data.
*    WHEN data_descr-&gt;typekind_simple.
*    WHEN data_descr-&gt;typekind_xsequence.
*    WHEN data_descr-&gt;typekind_numeric.
*    WHEN data_descr-&gt;typekind_iref.

*    WHEN OTHERS.

    ENDCASE.

  ENDMETHOD.</source>
 </method>
 <method CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="GET_JSON" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="8 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="GET_JSON" SCONAME="JSON" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="STRING"/>
  <source>METHOD get_json.

    get_json_large(
      IMPORTING
        json = json
    ).

  ENDMETHOD.</source>
 </method>
 <method CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="GET_JSON_LARGE" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="9 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="GET_JSON_LARGE" SCONAME="JSON" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
  <source>METHOD get_json_large.

    IF me-&gt;json IS NOT INITIAL.

      IF  me-&gt;json+0(1) NE `{`
      AND me-&gt;json+0(1) NE `[`.    &quot;sapcodexch issue #7

        &quot;*--- key/value pair only (sapcodexch issue #3) ---*
        FIND REGEX &apos;&quot;*&quot;:&apos; IN me-&gt;json.
        IF sy-subrc = 0.
*        me-&gt;json = `{` &amp;&amp; `}` &amp;&amp; me-&gt;json .            &quot;&gt;= 7.02
          CONCATENATE &apos;{&apos; me-&gt;json &apos;}&apos; INTO me-&gt;json.             &quot;&lt;= 7.01
        ENDIF.
      ENDIF.

    ENDIF.

    json = me-&gt;json.

    &quot;*--- surrounded object added in SET_JSON? -&gt; delete ---*
    IF me-&gt;object_added = abap_true.
      IF strlen( json ) &gt; 10.
        IF json(10) = &apos;{ &quot;itab&quot; :&apos;.
          SHIFT json CIRCULAR RIGHT UP TO &apos;]&apos;.       &quot;&apos;CIRCULAR&apos; because of STRING
          SHIFT json LEFT UP TO &apos;[&apos;.
        ENDIF.
      ENDIF.
    ENDIF.

    SHIFT json LEFT DELETING LEADING space.

  ENDMETHOD.</source>
 </method>
 <method CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="GET_KERNEL_INFO" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="15 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="GET_KERNEL_INFO" SCONAME="RELEASE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="GET_KERNEL_INFO" SCONAME="PATCH" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="I"/>
  <source>METHOD get_kernel_info.

    TYPES: BEGIN OF ts_kernel_version,
             key(21)  TYPE c,
             data(69) TYPE c,
           END OF ts_kernel_version.

    DATA kernel_version TYPE STANDARD TABLE OF ts_kernel_version.
    FIELD-SYMBOLS &lt;ls_kernel_version&gt; TYPE ts_kernel_version.

    CALL &apos;SAPCORE&apos; ID &apos;ID&apos; FIELD &apos;VERSION&apos;
                   ID &apos;TABLE&apos; FIELD kernel_version.

    &quot;*--- get kernel release ---*
    READ TABLE kernel_version
      ASSIGNING &lt;ls_kernel_version&gt;
      INDEX 12.

    CHECK sy-subrc = 0.

    release = &lt;ls_kernel_version&gt;-data.

    &quot;*--- get patch level ---*
    READ TABLE kernel_version
      ASSIGNING &lt;ls_kernel_version&gt;
      INDEX 15.

    CHECK sy-subrc = 0.

    patch = &lt;ls_kernel_version&gt;-data.

  ENDMETHOD.</source>
 </method>
 <method CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="GET_NAME_VALUE_PAIRS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="6 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="GET_NAME_VALUE_PAIRS" SCONAME="JSON" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING" PAROPTIONL="X"/>
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="GET_NAME_VALUE_PAIRS" SCONAME="DATE_FORMAT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CHAR10" PAROPTIONL="X"/>
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="GET_NAME_VALUE_PAIRS" SCONAME="DONT_REPLACE_LINEBREAKS" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="BOOLEAN" PAROPTIONL="X"/>
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="GET_NAME_VALUE_PAIRS" SCONAME="NAME_VALUES" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="WDY_KEY_VALUE_LIST"/>
  <exception CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="GET_NAME_VALUE_PAIRS" SCONAME="ZCX_JSON_DOCUMENT_3" VERSION="1" LANGU="E" MTDTYPE="0" EDITORDER="1 "/>
  <source>METHOD get_name_value_pairs.

    FIELD-SYMBOLS &lt;js_property&gt; TYPE js_property_description.
    FIELD-SYMBOLS &lt;name_value&gt; TYPE wdy_key_value.

    IF json IS NOT INITIAL.
      me-&gt;set_json(
        EXPORTING
          json                    = json
          date_format             = date_format
          dont_replace_linebreaks = dont_replace_linebreaks
      ).
    ENDIF.

    &quot;*--- properties not read yet? ---*
    IF js_property_table IS INITIAL.
      js_property_table = js-&gt;get_properties_scope_global( property_path = &apos;json_obj&apos; ).
    ENDIF.

    LOOP AT js_property_table
      ASSIGNING &lt;js_property&gt;
      WHERE kind &lt;&gt; &apos;O&apos;.

      INSERT INITIAL LINE INTO TABLE name_values ASSIGNING &lt;name_value&gt;.
      &lt;name_value&gt;-key = &lt;js_property&gt;-name.
      &lt;name_value&gt;-value = &lt;js_property&gt;-value.
    ENDLOOP.

  ENDMETHOD.</source>
 </method>
 <method CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="GET_NEXT" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="10 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="GET_NEXT" SCONAME="DATA_FOUND" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="BOOLEAN"/>
  <exception CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="GET_NEXT" SCONAME="ZCX_JSON_DOCUMENT_3" VERSION="1" LANGU="E" MTDTYPE="0" EDITORDER="1 "/>
  <source>METHOD get_next.

    DATA array_cursor_string TYPE string.
    DATA path_temp           TYPE string.
    DATA len                 TYPE i.

    FIELD-SYMBOLS &lt;line&gt; TYPE js_property_description.

    me-&gt;array_cursor = me-&gt;array_cursor + 1.
    array_cursor_string = me-&gt;array_cursor.   &quot;left without sign, in 7.40 = |{ me-&gt;array_cursor }|
    len = strlen( array_cursor_string ) - 1.
    array_cursor_string = array_cursor_string(len).

    &quot;the first time? -&gt; store the original path
    IF me-&gt;array_cursor = 0.
      me-&gt;array_property_path = me-&gt;js_property_path.

      &quot;*--- get the length of the array ---*
      me-&gt;set_path(
        i_path = me-&gt;array_property_path
        i_read = abap_true ).

      me-&gt;array_cursor_max = me-&gt;get_value( &apos;length&apos; ) - 1.

      &quot;*--- is it a string table (no structure)? -&gt; store ---*
      CLEAR me-&gt;js_property_string_table.

      READ TABLE me-&gt;js_property_table
        ASSIGNING &lt;line&gt;
        WITH KEY name = &apos;0&apos;.         &quot;read first line

      IF sy-subrc = 0.
        IF &lt;line&gt;-kind = &apos;S&apos;.
          me-&gt;js_property_string_table = me-&gt;js_property_table.
        ENDIF.
      ENDIF.
    ENDIF.

    &quot;*--- end of the array reached? ---*
    IF me-&gt;array_cursor &gt; me-&gt;array_cursor_max.
      &quot;reset path
      data_found = abap_false.
      me-&gt;array_cursor = -1.
      me-&gt;js_property_path = me-&gt;array_property_path.
      RETURN.
    ENDIF.

    &quot;*--- is it a structured table or a string table= ---*
    IF me-&gt;js_property_string_table IS NOT INITIAL.

      &quot;string table -&gt; we only have to read the correct line ---*
      READ TABLE me-&gt;js_property_string_table
        TRANSPORTING NO FIELDS
        WITH KEY name = array_cursor_string.

      IF sy-subrc = 0.
        data_found = abap_true.
      ELSE.
        &quot;no data found -&gt; reset path
        data_found = abap_false.

        me-&gt;array_cursor = -1.
        me-&gt;js_property_path = me-&gt;array_property_path.
      ENDIF.

    ELSE.

      &quot;structured table -&gt; go down the path ---*
      IF me-&gt;js_property_path IS INITIAL.  &quot;no path set yet
        path_temp = array_cursor_string.
      ELSE.

        CONCATENATE
          me-&gt;array_property_path &apos;.&apos;
          array_cursor_string
        INTO path_temp.
      ENDIF.

      me-&gt;set_path(
        i_path = path_temp
        i_read = abap_true ).

      &quot;(further) data in array found
      IF me-&gt;js_property_table IS NOT INITIAL.
        data_found = abap_true.
      ELSE.
        &quot;no data found -&gt; reset path
        data_found = abap_false.

        me-&gt;array_cursor = -1.
        me-&gt;js_property_path = me-&gt;array_property_path.
      ENDIF.

    ENDIF.

  ENDMETHOD.</source>
 </method>
 <method CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="GET_STRU" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="14 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="GET_STRU" SCONAME="LINE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
  <exception CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="GET_STRU" SCONAME="ZCX_JSON_DOCUMENT_3" VERSION="1" LANGU="E" MTDTYPE="0" EDITORDER="1 "/>
  <source>METHOD get_stru.

    DATA: stru_descr   TYPE REF TO cl_abap_structdescr
        , comp_name    TYPE string
        , lv_json      TYPE string
        .

    FIELD-SYMBOLS: &lt;value&gt; TYPE any
                 , &lt;component&gt; TYPE abap_compdescr
                 .

    stru_descr ?= cl_abap_typedescr=&gt;describe_by_data( line ).

    LOOP AT stru_descr-&gt;components
      ASSIGNING &lt;component&gt;.

      ASSIGN COMPONENT &lt;component&gt;-name OF STRUCTURE line TO &lt;value&gt;.

      comp_name = &lt;component&gt;-name.
      TRANSLATE comp_name TO LOWER CASE.
      lv_json = me-&gt;get_value( comp_name ).

      CHECK lv_json IS NOT INITIAL.    &quot;value found?  &quot;sapcodexch issue #6

      &quot;*--- and again -&gt; recursive! ---*
      me-&gt;get_data(
        EXPORTING json = lv_json
        IMPORTING data = &lt;value&gt;
        ).

    ENDLOOP.

  ENDMETHOD.</source>
 </method>
 <method CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="GET_TABLE" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="10 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="GET_TABLE" SCONAME="TABLE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY TABLE"/>
  <exception CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="GET_TABLE" SCONAME="ZCX_JSON_DOCUMENT_3" VERSION="1" LANGU="E" MTDTYPE="0" EDITORDER="1 "/>
  <source>METHOD get_table.

    DATA: table_descr  TYPE REF TO cl_abap_tabledescr
        , data_descr   TYPE REF TO cl_abap_datadescr
        , stru_descr   TYPE REF TO cl_abap_structdescr
        , comp_name    TYPE string
        , lv_json      TYPE string
        .

    FIELD-SYMBOLS: &lt;value&gt; TYPE any
                 , &lt;line&gt;  TYPE any
                 , &lt;component&gt; TYPE abap_compdescr
                 .

    table_descr ?= cl_abap_typedescr=&gt;describe_by_data( table ).

    &quot;*--- currently only standard tables possible (no hashed/sorted) ---*
    CHECK table_descr-&gt;table_kind = table_descr-&gt;tablekind_std.

    data_descr ?= table_descr-&gt;get_table_line_type( ).

    &quot;*--- check structure or simple ---*
    IF data_descr-&gt;type_kind = data_descr-&gt;typekind_struct1     &quot;flat strcuture
    OR data_descr-&gt;type_kind = data_descr-&gt;typekind_struct2.    &quot;deep strcuture
      stru_descr ?= data_descr.
    ENDIF.

    WHILE me-&gt;get_next( ) IS NOT INITIAL.

      INSERT INITIAL LINE INTO TABLE table ASSIGNING &lt;line&gt;.

      IF stru_descr IS NOT BOUND.    &quot;table line is not a structure

        DATA len                 TYPE i.
        DATA array_cursor_string TYPE string.
        FIELD-SYMBOLS &lt;property&gt; TYPE js_property_description.

        array_cursor_string = me-&gt;array_cursor.      &quot;left without sign, in 7.40 = |{ me-&gt;array_cursor }|
        len = strlen( array_cursor_string ) - 1.
        array_cursor_string = array_cursor_string(len).

        READ TABLE me-&gt;js_property_string_table
          ASSIGNING &lt;property&gt;
          WITH KEY name = array_cursor_string.

        IF sy-subrc = 0.
          &lt;line&gt; = &lt;property&gt;-value.
        ENDIF.

      ELSE.

        LOOP AT stru_descr-&gt;components
          ASSIGNING &lt;component&gt;.

          ASSIGN COMPONENT &lt;component&gt;-name OF STRUCTURE &lt;line&gt; TO &lt;value&gt;.

          comp_name = &lt;component&gt;-name.
          TRANSLATE comp_name TO LOWER CASE.
          lv_json = me-&gt;get_value( comp_name ).

          CHECK lv_json IS NOT INITIAL.    &quot;value found?  &quot;sapcodexch issue #6

          &quot;*--- and again -&gt; recursive! ---*
          me-&gt;get_data(
            EXPORTING json = lv_json
            IMPORTING data = &lt;value&gt;
            ).

        ENDLOOP.

      ENDIF.

    ENDWHILE.

  ENDMETHOD.</source>
 </method>
 <method CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="GET_VALUE" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="11 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="GET_VALUE" SCONAME="PATH" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING" PAROPTIONL="X"/>
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="GET_VALUE" SCONAME="KEY" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="GET_VALUE" SCONAME="VALUE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="STRING"/>
  <source>METHOD get_value.

    DATA path_temp TYPE string.
    DATA js_property_table_temp TYPE js_property_tab .

    FIELD-SYMBOLS &lt;property&gt; TYPE js_property_description.

    &quot;*--- use the temporary path ---*
    IF path IS NOT INITIAL.
      CONCATENATE &apos;json_obj.&apos; path INTO path_temp.
      js_property_table_temp = js_property_table.
      js_property_table = js-&gt;get_properties_scope_global( property_path = path_temp ).
    ELSEIF js_property_table IS INITIAL.
      &quot;*--- properties not yet read ---*
      IF js_property_path IS NOT INITIAL.
        CONCATENATE &apos;json_obj.&apos; js_property_path INTO path_temp.
      ELSE.
        path_temp = &apos;json_obj&apos;.      &quot;root path
      ENDIF.
      js_property_table = js-&gt;get_properties_scope_global( property_path = path_temp ).
    ENDIF.

    READ TABLE js_property_table WITH KEY name = key ASSIGNING &lt;property&gt;.

    IF sy-subrc = 0
    AND &lt;property&gt;-kind &lt;&gt; &apos;O&apos;.      &quot;not an object or table
      value = &lt;property&gt;-value.
    ENDIF.

    &quot;*--- temporary path given? Write back the original properties ---*
    IF js_property_table_temp IS NOT INITIAL.
      js_property_table = js_property_table_temp.
    ENDIF.

  ENDMETHOD.</source>
 </method>
 <method CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="GET_VALUE_INT" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="14 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="GET_VALUE_INT" SCONAME="PATH" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING" PAROPTIONL="X"/>
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="GET_VALUE_INT" SCONAME="KEY" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="GET_VALUE_INT" SCONAME="VALUE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="3" PARPASSTYP="0" TYPTYPE="1" TYPE="I"/>
  <source>METHOD get_value_int.

    DATA path_temp TYPE string.
    DATA js_property_table_temp TYPE js_property_tab .

    DATA: lv_value_string TYPE string.

    FIELD-SYMBOLS &lt;property&gt; TYPE js_property_description.

    &quot;*--- use the temporary path ---*
    IF path IS NOT INITIAL.
      CONCATENATE &apos;json_obj.&apos; path INTO path_temp.
      js_property_table_temp = js_property_table.
      js_property_table = js-&gt;get_properties_scope_global( property_path = path_temp ).
    ENDIF.

    READ TABLE js_property_table WITH KEY name = key ASSIGNING &lt;property&gt;.

    IF sy-subrc = 0
    AND &lt;property&gt;-kind &lt;&gt; &apos;O&apos;.      &quot;not an object or table
      lv_value_string = &lt;property&gt;-value.

      IF lv_value_string CO &apos; 1234567890-&apos;.
        value = lv_value_string.
      ENDIF.
    ENDIF.

    &quot;*--- temporary path given? Write back the original properties ---*
    IF js_property_table_temp IS NOT INITIAL.
      js_property_table = js_property_table_temp.
    ENDIF.


  ENDMETHOD.</source>
 </method>
 <method CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="PARSE" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="11 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="PARSE" SCONAME="JSON" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING" PAROPTIONL="X"/>
  <exception CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="PARSE" SCONAME="ZCX_JSON_DOCUMENT_3" VERSION="1" LANGU="E" MTDTYPE="0" EDITORDER="1 "/>
  <source>METHOD parse.

    DATA js_started TYPE i.
    DATA json_temp  TYPE string.
    DATA js_script  TYPE string.

    js = cl_java_script=&gt;create( ).

**************************************************************
*  Parse JSON using JavaScript                               *
*  used with friendly permission by Cesar Martin (SAP Spain) *
**************************************************************
    IF json IS NOT INITIAL.
      json_temp = json.
    ELSE.
      json_temp = me-&gt;json.
    ENDIF.

    js-&gt;bind( EXPORTING name_obj = &apos;abap_data&apos; name_prop = &apos;json_string&apos;    CHANGING data = json_temp ).
    js-&gt;bind( EXPORTING name_obj = &apos;abap_data&apos; name_prop = &apos;script_started&apos; CHANGING data = js_started ).

* We use the JavaScript engine included in ABAP to read the JSON string.
* We simply use the recommended way to eval a JSON string as specified
* in RFC 4627 (http://www.ietf.org/rfc/rfc4627.txt).
*
* Security considerations:
*
*   Generally there are security issues with scripting languages.  JSON
*   is a subset of JavaScript, but it is a safe subset that excludes
*   assignment and invocation.
*
*   A JSON text can be safely passed into JavaScript&apos;s eval() function
*   (which compiles and executes a string) if all the characters not
*   enclosed in strings are in the set of characters that form JSON
*   tokens.  This can be quickly determined in JavaScript with two
*   regular expressions and calls to the test and replace methods.
*
*      var my_JSON_object = !(/[^,:{}\[\]0-9.\-+Eaeflnr-u \n\r\t]/.test(
*             text.replace(/&quot;(\\.|[^&quot;\\])*&quot;/g, &apos;&apos;))) &amp;&amp;
*         eval(&apos;(&apos; + text + &apos;)&apos;);

    CONCATENATE

         &apos;var json_obj; &apos;
         &apos;var json_text; &apos;

         &apos;function start() { &apos;
         &apos;  if(abap_data.script_started) { return; } &apos;
         &apos;  json_text = abap_data.json_string;&apos;
         &apos;  json_obj = !(/[^,:{}\[\]0-9.\-+Eaeflnr-u \n\r\t]/.test( &apos;
         &apos;      json_text.replace(/&quot;(\\.|[^&quot;\\])*&quot;/g, &apos;&apos;&apos;&apos;))) &amp;&amp; &apos;
         &apos;    eval(&apos;&apos;(&apos;&apos; + json_text + &apos;&apos;)&apos;&apos;); &apos;
         &apos;  abap_data.script_started = 1; &apos;
         &apos;} &apos;

         &apos;if(!abap_data.script_started) start(); &apos;


       INTO js_script RESPECTING BLANKS SEPARATED BY cl_abap_char_utilities=&gt;newline.

    js-&gt;compile( script_name = &apos;json_parser&apos;     script = js_script ).
    js-&gt;execute( script_name = &apos;json_parser&apos; ).

    IF js-&gt;last_error_message IS NOT INITIAL.
      RAISE EXCEPTION TYPE zcx_json_document_3
        EXPORTING
          textid     = zcx_json_document_3=&gt;conversation_error
          error_text = js-&gt;last_error_message.
    ENDIF.

  ENDMETHOD.</source>
 </method>
 <method CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="REPLACE_NAMESPACE" VERSION="1" LANGU="E" EXPOSURE="0" STATE="1" EDITORDER="12 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="REPLACE_NAMESPACE" SCONAME="KEY" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="2" PARPASSTYP="1" TYPTYPE="1" TYPE="ABAP_COMPNAME"/>
  <source>METHOD replace_namespace.

    DATA namespace TYPE string.

    CHECK namespace_replace_pattern IS NOT INITIAL.

*    REPLACE REGEX `/(\w+)/` IN cv_key WITH mv_namespace_replace_pattern.  &quot;&gt;= 7.31

    &quot;*--- &lt; 7.31 ---*
    FIND REGEX `/(\w+)/` IN key SUBMATCHES namespace.

    IF namespace IS NOT INITIAL.
      REPLACE REGEX `/(\w+)/` IN key WITH namespace_replace_pattern.
      REPLACE &apos;&amp;1&apos; IN key WITH namespace.
      CONDENSE key.
    ENDIF.

  ENDMETHOD.</source>
 </method>
 <method CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="RESET_CURSOR" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="15 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <source>METHOD reset_cursor.
    me-&gt;array_cursor = -1.
    me-&gt;js_property_path = me-&gt;array_property_path.
  ENDMETHOD.</source>
 </method>
 <method CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="SET_DATA" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="16 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="SET_DATA" SCONAME="DATA" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="SET_DATA" SCONAME="SUPPRESS_ITAB" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="BOOLEAN" PAROPTIONL="X"/>
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="SET_DATA" SCONAME="IGNORE_BOOLEAN" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="BOOLEAN" PAROPTIONL="X"/>
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="SET_DATA" SCONAME="DONT_ESCAPE_LTGT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="BOOLEAN" PAROPTIONL="X"/>
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="SET_DATA" SCONAME="NUMC_AS_NUMERIC" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="BOOLEAN" PAROPTIONL="X"/>
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="SET_DATA" SCONAME="DATE_FORMAT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="6 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CHAR10" PAROPTIONL="X"/>
  <exception CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="SET_DATA" SCONAME="ZCX_JSON_DOCUMENT_3" VERSION="1" LANGU="E" MTDTYPE="0" EDITORDER="1 "/>
  <source>METHOD set_data.

    IF suppress_itab IS SUPPLIED.
      set_suppress_itab( suppress_itab ).
    ENDIF.

    IF ignore_boolean IS SUPPLIED.
      set_ignore_boolean( ignore_boolean ).
    ENDIF.

    IF dont_escape_ltgt IS SUPPLIED.
      set_dont_escape_ltgt( dont_escape_ltgt ).
    ENDIF.

    IF date_format IS SUPPLIED.
      set_date_format( date_format ).
    ENDIF.

    IF numc_as_numeric IS SUPPLIED.
      set_numc_as_numeric( numc_as_numeric ).
    ENDIF.

    CLEAR json.
    add_data( data ).

    parse( ).

  ENDMETHOD.</source>
 </method>
 <method CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="SET_DATE_FORMAT" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="18 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="SET_DATE_FORMAT" SCONAME="DATE_FORMAT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CHAR10"/>
  <source>METHOD set_date_format.

    me-&gt;date_format = date_format.

  ENDMETHOD.</source>
 </method>
 <method CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="SET_DONT_ESCAPE_LTGT" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="21 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="SET_DONT_ESCAPE_LTGT" SCONAME="DONT_ESCAPE_LTGT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="BOOLEAN"/>
  <source>METHOD set_dont_escape_ltgt.

    me-&gt;dont_escape_ltgt = dont_escape_ltgt.

  ENDMETHOD.</source>
 </method>
 <method CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="SET_DONT_REPLACE_LINEBREAKS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="20 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="SET_DONT_REPLACE_LINEBREAKS" SCONAME="DONT_REPLACE_LINEBREAKS" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="BOOLEAN"/>
  <source>METHOD set_dont_replace_linebreaks.
    me-&gt;dont_replace_linebreaks = dont_replace_linebreaks.
  ENDMETHOD.</source>
 </method>
 <method CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="SET_IGNORE_BOOLEAN" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="25 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="SET_IGNORE_BOOLEAN" SCONAME="IGNORE_BOOLEAN" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="BOOLEAN"/>
  <source>METHOD set_ignore_boolean.
    me-&gt;ignore_boolean = ignore_boolean.
  ENDMETHOD.</source>
 </method>
 <method CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="SET_JSON" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="22 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="SET_JSON" SCONAME="JSON" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="SET_JSON" SCONAME="DATE_FORMAT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CHAR10" PAROPTIONL="X"/>
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="SET_JSON" SCONAME="DONT_REPLACE_LINEBREAKS" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="BOOLEAN" PAROPTIONL="X"/>
  <exception CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="SET_JSON" SCONAME="ZCX_JSON_DOCUMENT_3" VERSION="1" LANGU="E" MTDTYPE="0" EDITORDER="1 "/>
  <source>METHOD set_json.

    IF date_format IS SUPPLIED.
      set_date_format( date_format ).
    ENDIF.

    IF dont_replace_linebreaks IS SUPPLIED.
      set_dont_replace_linebreaks( dont_replace_linebreaks ).
    ENDIF.

    me-&gt;json = json.

    &quot;*--- cl_java_script needs an object as top type ---*
    SHIFT me-&gt;json LEFT DELETING LEADING space.

    IF me-&gt;json(1) = &apos;[&apos;.
      &quot;*--- add a surrounding object ---*
      CONCATENATE
        &apos;{ &quot;itab&quot; : &apos;
        me-&gt;json
        &apos; }&apos;
      INTO me-&gt;json.

      me-&gt;object_added = abap_true.
    ELSE.
      CLEAR me-&gt;object_added.
    ENDIF.

    IF me-&gt;dont_replace_linebreaks &lt;&gt; abap_true.
      &quot;*--- esp. for CouchDB ---*
      REPLACE ALL OCCURRENCES OF cl_abap_char_utilities=&gt;cr_lf IN me-&gt;json WITH ``.
      REPLACE ALL OCCURRENCES OF cl_abap_char_utilities=&gt;newline IN me-&gt;json WITH ``.
    ENDIF.

    SHIFT me-&gt;json LEFT DELETING LEADING space.

    parse( ).

    IF me-&gt;object_added = abap_true.
      me-&gt;set_path( &apos;itab&apos; ).
    ENDIF.

  ENDMETHOD.</source>
 </method>
 <method CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="SET_NAMESPACE_CONVERSION" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="23 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="SET_NAMESPACE_CONVERSION" SCONAME="NAMESPACE_1_SLASH_REPLACE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="C"/>
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="SET_NAMESPACE_CONVERSION" SCONAME="NAMESPACE_2_SLASH_REPLACE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="C"/>
  <source>METHOD set_namespace_conversion.

    IF  namespace_1_slash_replace IS INITIAL
    AND namespace_2_slash_replace IS INITIAL.
      CLEAR namespace_replace_pattern.
    ELSE.
      CONCATENATE
        namespace_1_slash_replace
        &apos;&amp;1&apos;
        namespace_2_slash_replace
      INTO namespace_replace_pattern.
    ENDIF.

  ENDMETHOD.</source>
 </method>
 <method CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="SET_NAME_VALUE_PAIRS" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="7 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="SET_NAME_VALUE_PAIRS" SCONAME="NAME_VALUES" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="WDY_KEY_VALUE_LIST"/>
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="SET_NAME_VALUE_PAIRS" SCONAME="DATE_FORMAT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="CHAR10" PAROPTIONL="X"/>
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="SET_NAME_VALUE_PAIRS" SCONAME="DONT_REPLACE_LINEBREAKS" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="BOOLEAN" PAROPTIONL="X"/>
  <exception CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="SET_NAME_VALUE_PAIRS" SCONAME="ZCX_JSON_DOCUMENT_3" VERSION="1" LANGU="E" MTDTYPE="0" EDITORDER="1 "/>
  <source>METHOD set_name_value_pairs.

    FIELD-SYMBOLS &lt;name_value&gt; TYPE wdr_simple_name_value.

    json = &apos;{&apos;.
    LOOP AT name_values ASSIGNING &lt;name_value&gt;.

      &quot;*--- is value itself a JSON string? -&gt; no quotation marks ---*
      DATA value TYPE string.
      DATA off TYPE i.
      DATA is_json TYPE boolean.
      value = &lt;name_value&gt;-value.
      IF value IS NOT INITIAL.
        SHIFT value LEFT DELETING LEADING space.
        IF VALUE(1) CA &apos;{[&apos;.
          off = strlen( value ) - 1.   &quot;offset of last character
          IF value+off(1) CA &apos;]}&apos;.
            is_json = abap_true.    &quot;value is (probably) JSON
          ENDIF.
        ENDIF.
      ENDIF.

      IF is_json IS INITIAL.
        CONCATENATE
          json
          &apos;&quot;&apos;
          &lt;name_value&gt;-name
          &apos;&quot; :&quot;&apos;
          &lt;name_value&gt;-value
          &apos;&quot;&apos;
        INTO json.
      ELSE.
        CONCATENATE
          json
          &apos;&quot;&apos;
          &lt;name_value&gt;-name
          &apos;&quot; :&apos;
          &lt;name_value&gt;-value
        INTO json.
        CLEAR is_json.
      ENDIF.

      IF sy-tabix &lt;&gt; lines( name_values ).
        CONCATENATE
          json
          &apos;,&apos;
        INTO json.
      ENDIF.

    ENDLOOP.

    CONCATENATE
      json
      &apos; }&apos;
    INTO json.

    me-&gt;set_json(
      EXPORTING
        json                    = json
        date_format             = date_format
        dont_replace_linebreaks = dont_replace_linebreaks
    ).

  ENDMETHOD.</source>
 </method>
 <method CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="SET_NUMC_AS_NUMERIC" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="19 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="SET_NUMC_AS_NUMERIC" SCONAME="NUMC_AS_NUMERIC" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="BOOLEAN"/>
  <source>METHOD set_numc_as_numeric.

    me-&gt;numc_as_numeric = numc_as_numeric.

  ENDMETHOD.</source>
 </method>
 <method CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="SET_PATH" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="13 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="SET_PATH" SCONAME="I_PATH" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="SET_PATH" SCONAME="I_READ" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="BOOLEAN" PAROPTIONL="X"/>
  <exception CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="SET_PATH" SCONAME="ZCX_JSON_DOCUMENT_3" VERSION="1" LANGU="E" MTDTYPE="0" EDITORDER="1 "/>
  <source>METHOD set_path.

    DATA path_temp TYPE string.

    IF strlen( i_path ) &gt; 0.
      IF i_path(1) = &apos;.&apos;.      &quot;= append
        CONCATENATE js_property_path i_path INTO js_property_path.
      ELSE.
        js_property_path = i_path.
      ENDIF.
    ELSE.
      CLEAR js_property_path.
    ENDIF.

    &quot;*--- invalidate properties ---*
    IF i_read IS INITIAL.
      CLEAR js_property_table.
    ELSE.
      CONCATENATE &apos;json_obj.&apos; js_property_path INTO path_temp.
      js_property_table = js-&gt;get_properties_scope_global( property_path = path_temp ).

      IF js-&gt;last_error_message IS NOT INITIAL.
        RAISE EXCEPTION TYPE zcx_json_document_3
          EXPORTING
            textid     = zcx_json_document_3=&gt;java_script_error
            error_text = js-&gt;last_error_message.
      ENDIF.

    ENDIF.

  ENDMETHOD.</source>
 </method>
 <method CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="SET_SUPPRESS_ITAB" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="24 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="0" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="SET_SUPPRESS_ITAB" SCONAME="SUPPRESS_ITAB" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="BOOLEAN"/>
  <source>METHOD set_suppress_itab.

    me-&gt;suppress_itab = suppress_itab.

  ENDMETHOD.</source>
 </method>
 <method CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="TRANSFORM_SIMPLE" VERSION="1" LANGU="E" EXPOSURE="2" STATE="1" EDITORDER="26 " DISPID="0 " MTDTYPE="0" MTDDECLTYP="1" MTDNEWEXC="X" BCMTDCAT="00" BCMTDSYN="0">
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="TRANSFORM_SIMPLE" SCONAME="ROOT_NAME" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="1 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING" PARVALUE="&apos;RESULT&apos;"/>
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="TRANSFORM_SIMPLE" SCONAME="JSON_IN" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="2 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING" PAROPTIONL="X"/>
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="TRANSFORM_SIMPLE" SCONAME="DATA_IN" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="3 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY" PAROPTIONL="X"/>
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="TRANSFORM_SIMPLE" SCONAME="LOWER_CASE" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="4 " DISPID="0 " PARDECLTYP="0" PARPASSTYP="1" TYPTYPE="1" TYPE="BOOLEAN" PAROPTIONL="X"/>
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="TRANSFORM_SIMPLE" SCONAME="JSON_OUT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="5 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="STRING"/>
  <parameter CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="TRANSFORM_SIMPLE" SCONAME="DATA_OUT" VERSION="1" LANGU="E" CMPTYPE="1" MTDTYPE="0" EDITORDER="6 " DISPID="0 " PARDECLTYP="1" PARPASSTYP="1" TYPTYPE="1" TYPE="ANY"/>
  <exception CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="TRANSFORM_SIMPLE" SCONAME="ZCX_JSON_DOCUMENT_3" VERSION="1" LANGU="E" MTDTYPE="0" EDITORDER="1 "/>
  <exception CLSNAME="ZCL_JSON_DOCUMENT_3" CMPNAME="TRANSFORM_SIMPLE" SCONAME="CX_XSLT_FORMAT_ERROR" VERSION="1" LANGU="E" MTDTYPE="0" EDITORDER="2 "/>
  <source>METHOD transform_simple.

    &quot;see http://scn.sap.com/people/horst.keller/blog/2013/01/07/abap-and-json
    &quot;see also SAP note 1648418

    &quot;*--- first check kernel version ---*
    DATA release TYPE i.
    DATA patch TYPE i.

    get_kernel_info(
      IMPORTING
        release = release
        patch   = patch
        ).

    IF release &lt; 720
    OR release = 720 AND patch &lt; 116.
      RAISE EXCEPTION TYPE zcx_json_document_3
        EXPORTING
          textid = zcx_json_document_3=&gt;not_supported.
    ENDIF.

    &quot;*--- check whether current basis release supports JSON transformation ---*
    FIELD-SYMBOLS &lt;type&gt; TYPE if_sxml=&gt;xml_stream_type.

    ASSIGN (&apos;if_sxml=&gt;co_xt_json&apos;) TO &lt;type&gt;.

    IF &lt;type&gt; IS NOT ASSIGNED.
      RAISE EXCEPTION TYPE zcx_json_document_3
        EXPORTING
          textid = zcx_json_document_3=&gt;not_supported.
    ENDIF.

    &quot;*--- transform ---*
    DATA writer TYPE REF TO if_sxml_writer.
    DATA writer_out TYPE REF TO cl_sxml_string_writer.
    DATA reader TYPE REF TO if_sxml_reader.
    DATA jsonx TYPE xstring.
    DATA conv_in TYPE REF TO cl_abap_conv_in_ce.
    DATA param_t TYPE abap_trans_srcbind_tab.
    DATA node TYPE REF TO if_sxml_node.
    DATA node_el TYPE REF TO if_sxml_open_element.
    DATA att TYPE if_sxml_attribute=&gt;attributes.
    DATA varname TYPE string.

    FIELD-SYMBOLS &lt;param&gt; LIKE LINE OF param_t.
    FIELD-SYMBOLS &lt;att&gt; TYPE REF TO if_sxml_attribute.

    IF json_in IS NOT INITIAL.

      INSERT INITIAL LINE INTO TABLE param_t ASSIGNING &lt;param&gt;.
      &lt;param&gt;-name = root_name.
      GET REFERENCE OF data_out INTO &lt;param&gt;-value.

      &quot;*--- field names contain lower case character? ---*
      IF lower_case = abap_true.

        &quot;*--- convert field names to upper case ---*
        CALL METHOD (&apos;CL_ABAP_CODEPAGE&apos;)=&gt;convert_to  &quot;dyn call because of downward compatibility
          EXPORTING
            source = json_in    &quot; Source String
          RECEIVING
            result = jsonx.

        reader = cl_sxml_string_reader=&gt;create( jsonx ).
        writer ?= cl_sxml_string_writer=&gt;create( type = &lt;type&gt; ).   &quot;type = if_sxml=&gt;co_xt_json

        node = reader-&gt;read_next_node( ).

        WHILE node IS NOT INITIAL.

          IF node-&gt;type = if_sxml_node=&gt;co_nt_element_open.
            node_el ?= node.
            att = node_el-&gt;get_attributes( ).

            LOOP AT att ASSIGNING &lt;att&gt;.
              CHECK &lt;att&gt;-&gt;qname-name = &apos;name&apos;.
              varname = &lt;att&gt;-&gt;get_value( ).
              TRANSLATE varname TO UPPER CASE.
              &lt;att&gt;-&gt;set_value( varname ).
            ENDLOOP.

          ENDIF.

          writer-&gt;write_node( node ).

          node = reader-&gt;read_next_node( ).
        ENDWHILE.

        writer_out ?= writer.
        jsonx = writer_out-&gt;get_output( ).

        &quot;*--- JSONX (upper case) -&gt; ABAP ---*
        CALL TRANSFORMATION id SOURCE XML jsonx
                               RESULT (param_t).

      ELSE.

        &quot;*--- JSON -&gt; ABAP ---*
        CALL TRANSFORMATION id SOURCE XML json_in
                               RESULT (param_t).

      ENDIF.

    ELSE.
      &quot;*--- ABAP -&gt; JSON ---*
      INSERT INITIAL LINE INTO TABLE param_t ASSIGNING &lt;param&gt;.
      &lt;param&gt;-name = root_name.
      GET REFERENCE OF data_in INTO &lt;param&gt;-value.

      writer_out = cl_sxml_string_writer=&gt;create( type = &lt;type&gt; ).  &quot;type = if_sxml=&gt;co_xt_json
      CALL TRANSFORMATION id SOURCE (param_t)
                             RESULT XML writer_out.
      jsonx = writer_out-&gt;get_output( ).

      &quot;*--- field names as lower case characters? ---*
      IF lower_case = abap_true.

        reader = cl_sxml_string_reader=&gt;create( jsonx ).
        writer ?= cl_sxml_string_writer=&gt;create( type = &lt;type&gt; ).   &quot;type = if_sxml=&gt;co_xt_json

        node = reader-&gt;read_next_node( ).

        WHILE node IS NOT INITIAL.

          IF node-&gt;type = if_sxml_node=&gt;co_nt_element_open.
            node_el ?= node.
            att = node_el-&gt;get_attributes( ).

            LOOP AT att ASSIGNING &lt;att&gt;.
              CHECK &lt;att&gt;-&gt;qname-name = &apos;name&apos;.
              varname = &lt;att&gt;-&gt;get_value( ).
              TRANSLATE varname TO LOWER CASE.
              &lt;att&gt;-&gt;set_value( varname ).
            ENDLOOP.

          ENDIF.

          writer-&gt;write_node( node ).

          node = reader-&gt;read_next_node( ).
        ENDWHILE.

        writer_out ?= writer.
        jsonx = writer_out-&gt;get_output( ).

      ENDIF.

      &quot;*--- convert xstring to string ---*
      TRY.
          conv_in = cl_abap_conv_in_ce=&gt;create( input = jsonx ).
          conv_in-&gt;read( IMPORTING data = json_out ).

        CATCH cx_root.
*          ##no_handler     &quot;inactive for 7.01
      ENDTRY.

    ENDIF.

  ENDMETHOD.</source>
 </method>
</CLAS>
